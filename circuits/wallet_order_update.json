{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":14852719153010836923,"abi":{"parameters":[{"name":"old_wallet_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"new_wallet_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"old_merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"user_secret","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"old_available_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_reserved_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_orders_list","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_fees","type":{"kind":"field"},"visibility":"private"},{"name":"old_index","type":{"kind":"field"},"visibility":"private"},{"name":"old_hash_path","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_available_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_reserved_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_orders_list","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"operation_type","type":{"kind":"field"},"visibility":"private"},{"name":"order_index","type":{"kind":"field"},"visibility":"private"},{"name":"order_id","type":{"kind":"field"},"visibility":"private"},{"name":"order_direction","type":{"kind":"field"},"visibility":"private"},{"name":"order_price","type":{"kind":"field"},"visibility":"private"},{"name":"order_quantity","type":{"kind":"field"},"visibility":"private"},{"name":"order_token_in","type":{"kind":"field"},"visibility":"private"},{"name":"order_token_out","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"72":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse crate::constants::GLOBAL_DEPTH;\n\npub fn excute_merkle_root(\n    commitment: Field,\n    hash_path: [Field; GLOBAL_DEPTH],\n    index: u32,\n) -> Field {\n    let mut hash = commitment;\n\n    for i in 0..GLOBAL_DEPTH {\n        let is_right = ((index >> (i as u8)) & 1) == 1;\n        hash = if is_right {\n            Poseidon2::hash([hash, hash_path[i]], 2)\n        } else {\n            Poseidon2::hash([hash_path[i], hash], 2)\n        };\n    }\n    hash\n}","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/common/src/merkle.nr"},"74":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/gary/nargo/github.com/noir-lang/poseidonv0.1.1/src/poseidon2.nr"},"81":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse dep::common::merkle::excute_merkle_root;\nuse dep::common::constants::{\n    GLOBAL_DEPTH,\n    MAX_PENDING_ORDER,\n    TOTAL_TOKEN,\n    SELL,\n    OP_CREATE_ORDER,\n    OP_CANCEL_ORDER,\n    TOTAL_ORDER_OP,\n};\n\nfn main(\n    // PUBLIC \n    old_wallet_commitment: pub Field,\n    new_wallet_commitment: pub Field,      \n    old_merkle_root: pub Field,\n    // PRIVATE \n    user_secret: Field,\n    nonce: Field,\n    old_available_balances: [Field; TOTAL_TOKEN],\n    old_reserved_balances: [Field; TOTAL_TOKEN],\n    old_orders_list: [Field; MAX_PENDING_ORDER],\n    old_fees: Field,\n    old_index: Field,\n    old_hash_path: [Field; GLOBAL_DEPTH],\n    // PRIVATE \n    new_available_balances: [Field; TOTAL_TOKEN],\n    new_reserved_balances: [Field; TOTAL_TOKEN],\n    new_orders_list: [Field; MAX_PENDING_ORDER],\n    // PRIVATE  \n    operation_type: Field,                 \n    order_index: Field,                    \n    order_id: Field,                       \n    order_direction: Field,               \n    order_price: Field,                    \n    order_quantity: Field,                 \n    order_token_in: Field,                \n    order_token_out: Field                 \n) -> pub (Field, Field, Field) {\n\n    // 1. VALIDATE INPUTS\n    let nonce_int = nonce as u32;\n    let order_index_int = order_index as u32;\n    let order_token_in_int = order_token_in as u32;\n    let order_token_out_int = order_token_out as u32;\n    let operation_type_int = operation_type as u32;\n    assert(operation_type_int < TOTAL_ORDER_OP);\n    assert(order_index_int < MAX_PENDING_ORDER);\n\n    let price_int = order_price as i32;\n    let quantity_int = order_quantity as i32;\n    let direction_int = order_direction as i32;\n    assert(price_int > 0);\n    assert(quantity_int > 0);\n    assert(direction_int >= 0);\n    assert(direction_int <= 1);\n    assert(order_token_in_int < TOTAL_TOKEN);\n    assert(order_token_out_int < TOTAL_TOKEN);\n    assert(order_token_in != order_token_out);\n\n    let old_randomness = Poseidon2::hash([user_secret, nonce], 2);\n    let new_randomness = Poseidon2::hash([user_secret, (nonce_int + 1) as Field], 2);\n\n    let old_available_hash = Poseidon2::hash(old_available_balances, TOTAL_TOKEN);\n    let old_reserved_hash = Poseidon2::hash(old_reserved_balances, TOTAL_TOKEN);\n    let old_orders_hash = Poseidon2::hash(old_orders_list, MAX_PENDING_ORDER);\n\n    let computed_old_commitment = Poseidon2::hash(\n        [old_available_hash, old_reserved_hash, old_orders_hash, old_fees, old_randomness],\n        5\n    );\n    assert(computed_old_commitment == old_wallet_commitment);\n\n    let old_index_int = old_index as u32;\n    assert(old_merkle_root == excute_merkle_root(old_wallet_commitment, old_hash_path, old_index_int));\n\n    if operation_type_int == OP_CREATE_ORDER {\n        assert(old_orders_list[order_index_int] == 0);\n\n        if order_direction == SELL {\n            let check_amount = old_available_balances[order_token_out_int].lt(order_quantity);\n            assert(!check_amount);\n\n            assert(new_available_balances[order_token_out_int] == old_available_balances[order_token_out_int] - order_quantity);\n            assert(new_reserved_balances[order_token_out_int] == old_reserved_balances[order_token_out_int] + order_quantity);\n        } else {\n            // BUY\n            let total_cost = order_price * order_quantity;\n            let check_amount = old_available_balances[order_token_out_int].lt(total_cost);\n            assert(!check_amount);\n\n            assert(new_available_balances[order_token_out_int] == old_available_balances[order_token_out_int] - total_cost);\n            assert(new_reserved_balances[order_token_out_int] == old_reserved_balances[order_token_out_int] + total_cost);\n        }\n\n        for i in 0..TOTAL_TOKEN {\n            if i != order_token_out_int {\n                assert(new_available_balances[i] == old_available_balances[i]);\n                assert(new_reserved_balances[i] == old_reserved_balances[i]);\n            }\n        }\n\n        let new_order = [order_id, order_price, order_quantity, order_direction, order_token_in, order_token_out];\n        let new_order_commitment = Poseidon2::hash(new_order, new_order.len());\n\n        assert(new_orders_list[order_index_int] == new_order_commitment);\n\n        for i in 0..MAX_PENDING_ORDER {\n            if i != order_index_int {\n                assert(new_orders_list[i] == old_orders_list[i]);\n            }\n        }\n\n    } else {\n        assert(operation_type_int == OP_CANCEL_ORDER);\n        assert(old_orders_list[order_index_int] != 0);\n\n        let expected_order = [order_id, order_price, order_quantity, order_direction, order_token_in, order_token_out];\n        let expected_order_commitment = Poseidon2::hash(expected_order, expected_order.len());\n        assert(old_orders_list[order_index_int] == expected_order_commitment);\n\n        if order_direction == SELL {\n            assert(new_available_balances[order_token_out_int] == old_available_balances[order_token_out_int] + order_quantity);\n            assert(new_reserved_balances[order_token_out_int] == old_reserved_balances[order_token_out_int] - order_quantity);\n        } else {\n            let total_cost = order_price * order_quantity;\n            assert(new_available_balances[order_token_out_int] == old_available_balances[order_token_out_int] + total_cost);\n            assert(new_reserved_balances[order_token_out_int] == old_reserved_balances[order_token_out_int] - total_cost);\n        }\n\n        for i in 0..TOTAL_TOKEN {\n            if i != order_token_out_int {\n                assert(new_available_balances[i] == old_available_balances[i]);\n                assert(new_reserved_balances[i] == old_reserved_balances[i]);\n            }\n        }\n        assert(new_orders_list[order_index_int] == 0);\n\n        for i in 0..MAX_PENDING_ORDER {\n            if i != order_index_int {\n                assert(new_orders_list[i] == old_orders_list[i]);\n            }\n        }\n    }\n\n    let new_available_hash = Poseidon2::hash(new_available_balances, TOTAL_TOKEN);\n    let new_reserved_hash = Poseidon2::hash(new_reserved_balances, TOTAL_TOKEN);\n    let new_orders_hash = Poseidon2::hash(new_orders_list, MAX_PENDING_ORDER);\n\n    let computed_new_commitment = Poseidon2::hash(\n        [new_available_hash, new_reserved_hash, new_orders_hash, old_fees, new_randomness],\n        5\n    );\n    assert(computed_new_commitment == new_wallet_commitment);\n\n    let nullifier = Poseidon2::hash([user_secret, old_wallet_commitment], 2);\n    (nullifier, new_wallet_commitment, nonce + 1)\n}\n","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/wallet_order_update/src/main.nr"}},"names":["main"],"brillig_names":["lt_32_hint","decompose_hint","lte_16_hint","directive_integer_quotient","directive_invert"]}