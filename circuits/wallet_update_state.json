{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":4728582913204006818,"abi":{"parameters":[{"name":"old_wallet_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"new_wallet_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"old_merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"transfer_direction","type":{"kind":"field"},"visibility":"public"},{"name":"transfer_mint","type":{"kind":"field"},"visibility":"public"},{"name":"transfer_amount","type":{"kind":"field"},"visibility":"public"},{"name":"operation_type","type":{"kind":"field"},"visibility":"public"},{"name":"user_secret","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"old_available_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_reserved_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_orders_list","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_fees","type":{"kind":"field"},"visibility":"private"},{"name":"old_index","type":{"kind":"field"},"visibility":"private"},{"name":"old_hash_path","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_available_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_reserved_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_orders_list","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"transfer_index","type":{"kind":"field"},"visibility":"private"},{"name":"order_index","type":{"kind":"field"},"visibility":"private"},{"name":"order_direction","type":{"kind":"field"},"visibility":"private"},{"name":"order_price","type":{"kind":"field"},"visibility":"private"},{"name":"order_quantity","type":{"kind":"field"},"visibility":"private"},{"name":"order_token_in","type":{"kind":"field"},"visibility":"private"},{"name":"order_token_out","type":{"kind":"field"},"visibility":"private"},{"name":"order_operation_type","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"72":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse crate::constants::GLOBAL_DEPTH;\n\npub fn excute_merkle_root(\n    commitment: Field,\n    hash_path: [Field; GLOBAL_DEPTH],\n    index: u32,\n) -> Field {\n    let mut hash = commitment;\n\n    for i in 0..GLOBAL_DEPTH {\n        let is_right = ((index >> (i as u8)) & 1) == 1;\n        hash = if is_right {\n            Poseidon2::hash([hash, hash_path[i]], 2)\n        } else {\n            Poseidon2::hash([hash_path[i], hash], 2)\n        };\n    }\n    hash\n}","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/common/src/merkle.nr"},"74":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/gary/nargo/github.com/noir-lang/poseidonv0.1.1/src/poseidon2.nr"},"84":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse dep::common::merkle::excute_merkle_root;\nuse dep::common::constants::{\n    GLOBAL_DEPTH,\n    MAX_PENDING_ORDER,\n    TOTAL_TOKEN,\n    TRANSFER_DEPOSIT,\n    TRANSFER_WITHDRAW,\n    SELL,\n    BUY,\n    OP_CREATE_ORDER,\n    OP_CANCEL_ORDER,\n    TOTAL_ORDER_OP,\n};\n\nfn main(\n    // PUBLIC INPUTS\n    old_wallet_commitment: pub Field,\n    new_wallet_commitment: pub Field,\n    old_merkle_root: pub Field,\n\n    // External transfer (public - visible on-chain)\n    transfer_direction: pub Field,\n    transfer_mint: pub Field,\n    transfer_amount: pub Field,\n    operation_type: pub Field,  // 0 = transfer only, 1 = order only, 2 = both\n\n    // PRIVATE WITNESS\n    user_secret: Field,\n    nonce: Field,\n\n    // Old wallet state\n    old_available_balances: [Field; TOTAL_TOKEN],\n    old_reserved_balances: [Field; TOTAL_TOKEN],\n    old_orders_list: [Field; MAX_PENDING_ORDER],\n    old_fees: Field,\n    old_index: Field,\n    old_hash_path: [Field; GLOBAL_DEPTH],\n\n    // New wallet state\n    new_available_balances: [Field; TOTAL_TOKEN],\n    new_reserved_balances: [Field; TOTAL_TOKEN],\n    new_orders_list: [Field; MAX_PENDING_ORDER],\n\n    // Transfer-specific witness\n    transfer_index: Field,\n\n    // Order-specific witness\n    order_index: Field,\n    order_direction: Field,\n    order_price: Field,\n    order_quantity: Field,\n    order_token_in: Field,\n    order_token_out: Field,\n    order_operation_type: Field,  \n) -> pub (Field, Field, Field) {\n    let nonce_int = nonce as u32;\n    let operation_type_int = operation_type as u32;\n    assert(operation_type_int <= 2, \"Invalid operation type\");\n\n    // Transfer validation (only if operation involves transfer)\n    let transfer_is_active = (operation_type_int == 0) | (operation_type_int == 2);\n    if transfer_is_active {\n        let transfer_index_int = transfer_index as u32;\n        let transfer_mint_int = transfer_mint as u32;\n        let transfer_direction_int = transfer_direction as u32;\n\n        assert(\n            (transfer_direction_int == TRANSFER_DEPOSIT) | (transfer_direction_int == TRANSFER_WITHDRAW),\n            \"Transfer direction must be DEPOSIT or WITHDRAW\"\n        );\n        assert(transfer_index_int < TOTAL_TOKEN, \"Transfer index out of bounds\");\n        assert(transfer_mint_int < TOTAL_TOKEN, \"Transfer mint token out of bounds\");\n\n        let transfer_amount_int = transfer_amount as i32;\n        assert(transfer_amount_int > 0, \"Transfer amount must be positive\");\n    }\n\n    // Order validation (only if operation involves order)\n    let order_is_active = (operation_type_int == 1) | (operation_type_int == 2);\n    if order_is_active {\n        let order_index_int = order_index as u32;\n        let order_token_in_int = order_token_in as u32;\n        let order_token_out_int = order_token_out as u32;\n        let order_operation_type_int = order_operation_type as u32;\n\n        assert(order_operation_type_int < TOTAL_ORDER_OP, \"Invalid order operation type\");\n        assert(order_index_int < MAX_PENDING_ORDER, \"Order index out of bounds\");\n\n        let price_int = order_price as i32;\n        let quantity_int = order_quantity as i32;\n\n        assert(price_int > 0, \"Price must be positive\");\n        assert(quantity_int > 0, \"Quantity must be positive\");\n\n        // FIX: Validate order_direction matches constants (not just in {0,1})\n        assert(\n            (order_direction == BUY) | (order_direction == SELL),\n            \"Order direction must be BUY or SELL constant\"\n        );\n\n        assert(order_token_in_int < TOTAL_TOKEN, \"Order token_in out of bounds\");\n        assert(order_token_out_int < TOTAL_TOKEN, \"Order token_out out of bounds\");\n        assert(order_token_in != order_token_out, \"Cannot trade same token\");\n    }\n\n    let old_randomness = Poseidon2::hash([user_secret, nonce], 2);\n\n    let old_available_hash = Poseidon2::hash(old_available_balances, TOTAL_TOKEN);\n    let old_reserved_hash = Poseidon2::hash(old_reserved_balances, TOTAL_TOKEN);\n    let old_orders_hash = Poseidon2::hash(old_orders_list, MAX_PENDING_ORDER);\n\n    let computed_old_commitment = Poseidon2::hash(\n        [old_available_hash, old_reserved_hash, old_orders_hash, old_fees, old_randomness],\n        5\n    );\n    assert(computed_old_commitment == old_wallet_commitment, \"Old wallet commitment mismatch\");\n\n    // Verify Merkle inclusion proof\n    let old_index_int = old_index as u32;\n    assert(\n        old_merkle_root == excute_merkle_root(old_wallet_commitment, old_hash_path, old_index_int),\n        \"Invalid Merkle proof\"\n    );\n\n    let mut intermediate_available = old_available_balances;\n    let mut intermediate_reserved = old_reserved_balances;\n\n    // process transfer (if active)\n    if transfer_is_active {\n        let transfer_index_int = transfer_index as u32;\n        let transfer_direction_int = transfer_direction as u32;\n\n        if transfer_direction_int == TRANSFER_DEPOSIT {\n            // Deposit: increase available balance\n            intermediate_available[transfer_index_int] = old_available_balances[transfer_index_int] + transfer_amount;\n            intermediate_reserved[transfer_index_int] = old_reserved_balances[transfer_index_int];\n\n            // Verify other balances unchanged\n            for i in 0..TOTAL_TOKEN {\n                if i != transfer_index_int {\n                    assert(\n                        intermediate_available[i] == old_available_balances[i],\n                        \"Available balance changed unexpectedly during deposit\"\n                    );\n                    assert(\n                        intermediate_reserved[i] == old_reserved_balances[i],\n                        \"Reserved balance changed unexpectedly during deposit\"\n                    );\n                }\n            }\n        } else {\n            // Withdrawal: decrease available balance\n            let check_amount = old_available_balances[transfer_index_int].lt(transfer_amount);\n            assert(!check_amount, \"Insufficient balance for withdrawal\");\n\n            intermediate_available[transfer_index_int] = old_available_balances[transfer_index_int] - transfer_amount;\n            intermediate_reserved[transfer_index_int] = old_reserved_balances[transfer_index_int];\n\n            assert(old_fees == 0, \"Must settle fees before withdrawal\");\n\n            for i in 0..TOTAL_TOKEN {\n                if i != transfer_index_int {\n                    assert(\n                        intermediate_available[i] == old_available_balances[i],\n                        \"Available balance changed unexpectedly during withdrawal\"\n                    );\n                    assert(\n                        intermediate_reserved[i] == old_reserved_balances[i],\n                        \"Reserved balance changed unexpectedly during withdrawal\"\n                    );\n                }\n            }\n        }\n    }\n\n    // process order (if active)\n    let mut final_available = intermediate_available;\n    let mut final_reserved = intermediate_reserved;\n    let mut final_orders = old_orders_list;\n\n    if order_is_active {\n        let order_index_int = order_index as u32;\n        let order_token_out_int = order_token_out as u32;\n        let order_operation_type_int = order_operation_type as u32;\n\n        if order_operation_type_int == OP_CREATE_ORDER {\n            assert(old_orders_list[order_index_int] == 0, \"Order slot must be empty\");\n\n            // Balance will be checked at match time, not placement time\n            if order_direction == SELL {\n                // SELL: reserve tokens from available balance\n                let check_amount = intermediate_available[order_token_out_int].lt(order_quantity);\n                assert(!check_amount, \"Insufficient available balance for order\");\n\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] - order_quantity;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] + order_quantity;\n            } else {\n\n                let total_cost = order_price * order_quantity;\n\n                assert(\n                    total_cost.lt(order_price) == false,\n                    \"Order cost overflow - price * quantity too large\"\n                );\n\n                let check_amount = intermediate_available[order_token_out_int].lt(total_cost);\n                assert(!check_amount, \"Insufficient available balance for order\");\n\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] - total_cost;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] + total_cost;\n            }\n\n            for i in 0..TOTAL_TOKEN {\n                if i != order_token_out_int {\n                    assert(\n                        final_available[i] == intermediate_available[i],\n                        \"Available balance changed unexpectedly during order creation\"\n                    );\n                    assert(\n                        final_reserved[i] == intermediate_reserved[i],\n                        \"Reserved balance changed unexpectedly during order creation\"\n                    );\n                }\n            }\n\n            // Create order commitment\n            let new_order = [order_price, order_quantity, order_direction, order_token_in, order_token_out];\n            let new_order_commitment = Poseidon2::hash(new_order, new_order.len());\n\n            final_orders[order_index_int] = new_order_commitment;\n\n            // Verify other orders unchanged\n            for i in 0..MAX_PENDING_ORDER {\n                if i != order_index_int {\n                    assert(\n                        final_orders[i] == old_orders_list[i],\n                        \"Other orders changed unexpectedly during order creation\"\n                    );\n                }\n            }\n\n        } else {\n            // Cancel Order\n            assert(order_operation_type_int == OP_CANCEL_ORDER, \"Invalid order operation for cancellation\");\n            assert(old_orders_list[order_index_int] != 0, \"Order slot must be filled for cancellation\");\n\n            // Verify order details match\n            let expected_order = [order_price, order_quantity, order_direction, order_token_in, order_token_out];\n            let expected_order_commitment = Poseidon2::hash(expected_order, expected_order.len());\n            assert(\n                old_orders_list[order_index_int] == expected_order_commitment,\n                \"Order details mismatch - cancellation data does not match existing order\"\n            );\n\n            if order_direction == SELL {\n                // SELL cancellation: return reserved to available\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] + order_quantity;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] - order_quantity;\n            } else {\n                // BUY cancellation: return reserved cost to available\n                let total_cost = order_price * order_quantity;\n                assert(\n                    total_cost.lt(order_price) == false,\n                    \"Order cost overflow during cancellation\"\n                );\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] + total_cost;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] - total_cost;\n            }\n\n            // Verify other balances unchanged\n            for i in 0..TOTAL_TOKEN {\n                if i != order_token_out_int {\n                    assert(\n                        final_available[i] == intermediate_available[i],\n                        \"Available balance changed unexpectedly during order cancellation\"\n                    );\n                    assert(\n                        final_reserved[i] == intermediate_reserved[i],\n                        \"Reserved balance changed unexpectedly during order cancellation\"\n                    );\n                }\n            }\n            final_orders[order_index_int] = 0;\n            for i in 0..MAX_PENDING_ORDER {\n                if i != order_index_int {\n                    assert(\n                        final_orders[i] == old_orders_list[i],\n                        \"Other orders changed unexpectedly during order cancellation\"\n                    );\n                }\n            }\n        }\n    }\n    //  No transfer, no order, only update metadata\n    if !transfer_is_active & !order_is_active {\n        for i in 0..TOTAL_TOKEN {\n            assert(\n                final_available[i] == old_available_balances[i],\n                \"Available balance should not change without transfer or order\"\n            );\n            assert(\n                final_reserved[i] == old_reserved_balances[i],\n                \"Reserved balance should not change without transfer or order\"\n            );\n        }\n        for i in 0..MAX_PENDING_ORDER {\n            assert(\n                final_orders[i] == old_orders_list[i],\n                \"Orders should not change without order operation\"\n            );\n        }\n    }\n    for i in 0..TOTAL_TOKEN {\n        assert(\n            new_available_balances[i] == final_available[i],\n            \"New available balance does not match computed state\"\n        );\n        assert(\n            new_reserved_balances[i] == final_reserved[i],\n            \"New reserved balance does not match computed state\"\n        );\n    }\n    for i in 0..MAX_PENDING_ORDER {\n        assert(\n            new_orders_list[i] == final_orders[i],\n            \"New orders list does not match computed state\"\n        );\n    }\n    let new_randomness = Poseidon2::hash([user_secret, (nonce_int + 1) as Field], 2);\n    let new_available_hash = Poseidon2::hash(new_available_balances, TOTAL_TOKEN);\n    let new_reserved_hash = Poseidon2::hash(new_reserved_balances, TOTAL_TOKEN);\n    let new_orders_hash = Poseidon2::hash(new_orders_list, MAX_PENDING_ORDER);\n\n    let computed_new_commitment = Poseidon2::hash(\n        [new_available_hash, new_reserved_hash, new_orders_hash, old_fees, new_randomness],\n        5\n    );\n    assert(computed_new_commitment == new_wallet_commitment, \"New wallet commitment mismatch\");\n\n    let nullifier = Poseidon2::hash([user_secret, old_wallet_commitment], 2);\n\n    (nullifier, new_wallet_commitment, nonce + 1)\n}\n","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/wallet_update_state/src/main.nr"}},"names":["main"],"brillig_names":["lt_32_hint","decompose_hint","lte_16_hint","directive_integer_quotient","directive_invert"]}