{
  "noir_version": "0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab",
  "hash": 17513586378219130030,
  "abi": {
    "parameters": [
      {
        "name": "old_wallet_commitment",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "new_wallet_commitment",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "old_merkle_root",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "transfer_direction",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "transfer_mint",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "transfer_amount",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "operation_type",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "old_wallet",
        "type": {
          "kind": "struct",
          "path": "common::data::Wallet",
          "fields": [
            {
              "name": "available_balances",
              "type": {
                "kind": "array",
                "length": 10,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "reserved_balances",
              "type": {
                "kind": "array",
                "length": 10,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "orders_list",
              "type": {
                "kind": "array",
                "length": 4,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "fees",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "keys",
              "type": {
                "kind": "struct",
                "path": "common::data::PublicKeyChain",
                "fields": [
                  {
                    "name": "pk_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "pk_match",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "blinder",
              "type": {
                "kind": "field"
              }
            }
          ]
        },
        "visibility": "private"
      },
      {
        "name": "old_index",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "old_hash_path",
        "type": {
          "kind": "array",
          "length": 16,
          "type": {
            "kind": "field"
          }
        },
        "visibility": "private"
      },
      {
        "name": "new_blinder",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "transfer_index",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_index",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_direction",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_price",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_quantity",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_token_in",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_token_out",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_operation_type",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "field"
      },
      "visibility": "public"
    },
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "25": {
      "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "26": {
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n",
      "path": "std/field/mod.nr"
    },
    "72": {
      "source": "use dep::poseidon::poseidon2::Poseidon2;\nuse crate::constants::GLOBAL_DEPTH;\n\npub fn excute_merkle_root(\n    commitment: Field,\n    hash_path: [Field; GLOBAL_DEPTH],\n    index: u32,\n) -> Field {\n    let mut hash = commitment;\n\n    for i in 0..GLOBAL_DEPTH {\n        let is_right = ((index >> (i as u8)) & 1) == 1;\n        hash = if is_right {\n            Poseidon2::hash([hash, hash_path[i]], 2)\n        } else {\n            Poseidon2::hash([hash_path[i], hash], 2)\n        };\n    }\n    hash\n}",
      "path": "/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/common/src/merkle.nr"
    },
    "73": {
      "source": "use dep::poseidon::poseidon2::Poseidon2;\nuse crate::constants::{\n    MAX_PENDING_ORDER,\n    TOTAL_TOKEN,\n};\n\npub struct Order {\n    pub price: Field,\n    pub quantity: Field,\n    pub direction: Field,\n    pub token_in: Field,\n    pub token_out: Field,\n}\n\npub struct PublicKeyChain {\n    pub pk_root: Field,\n    pub pk_match: Field,  // Public matching key = Poseidon(sk_match)\n    pub nonce: Field,     // Nonce for key rotation (0 for no rotation)\n}\n\npub struct Wallet {\n    pub available_balances: [Field; TOTAL_TOKEN],\n    pub reserved_balances: [Field; TOTAL_TOKEN],\n    pub orders_list: [Field; MAX_PENDING_ORDER],\n    pub fees: Field,\n    pub keys: PublicKeyChain,  // Public key chain\n    pub blinder: Field,        // Randomness for commitment\n}\n\n// Shared helper functions\npub fn compute_wallet_commitment(wallet: Wallet) -> Field {\n    let available_hash = Poseidon2::hash(wallet.available_balances, TOTAL_TOKEN);\n    let reserved_hash = Poseidon2::hash(wallet.reserved_balances, TOTAL_TOKEN);\n    let orders_hash = Poseidon2::hash(wallet.orders_list, MAX_PENDING_ORDER);\n\n    // Hash the public key chain (pk_root, pk_match, nonce)\n    let keys_hash = Poseidon2::hash(\n        [wallet.keys.pk_root, wallet.keys.pk_match, wallet.keys.nonce],\n        3\n    );\n\n    // Commitment = Hash(balances, orders, keys, fees, blinder)\n    Poseidon2::hash(\n        [available_hash, reserved_hash, orders_hash, keys_hash, wallet.fees, wallet.blinder],\n        6\n    )\n}\n\npub fn compute_order_commitment(order: Order) -> Field {\n    let order_array = [order.price, order.quantity, order.direction, order.token_in, order.token_out];\n    Poseidon2::hash(order_array, 5)\n}\n",
      "path": "/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/common/src/data.nr"
    },
    "75": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "/Users/gary/nargo/github.com/noir-lang/poseidonv0.1.1/src/poseidon2.nr"
    },
    "83": {
      "source": "use dep::poseidon::poseidon2::Poseidon2;\nuse dep::common::merkle::excute_merkle_root;\nuse dep::common::constants::{\n    GLOBAL_DEPTH,\n    MAX_PENDING_ORDER,\n    TOTAL_TOKEN,\n    TRANSFER_DEPOSIT,\n    TRANSFER_WITHDRAW,\n    SELL,\n    BUY,\n    OP_CREATE_ORDER,\n    OP_CANCEL_ORDER,\n    TOTAL_ORDER_OP,\n};\n\nuse dep::common::data::{\n    Wallet,\n    PublicKeyChain,\n    Order,\n    compute_wallet_commitment,\n    compute_order_commitment,\n};\n\nfn main(\n    // PUBLIC INPUTS\n    old_wallet_commitment: pub Field,\n    new_wallet_commitment: pub Field,\n    old_merkle_root: pub Field,\n\n    // External transfer (public - visible on-chain)\n    transfer_direction: pub Field,\n    transfer_mint: pub Field,\n    transfer_amount: pub Field,\n    operation_type: pub Field,  // 0 = transfer only, 1 = order only, 2 = both\n\n    // PRIVATE WITNESS\n    old_wallet: Wallet,\n    old_index: Field,\n    old_hash_path: [Field; GLOBAL_DEPTH],\n    new_blinder: Field,  // New blinder for new commitment\n\n    // Transfer-specific witness\n    transfer_index: Field,\n\n    // Order-specific witness\n    order_index: Field,\n    order_direction: Field,\n    order_price: Field,\n    order_quantity: Field,\n    order_token_in: Field,\n    order_token_out: Field,\n    order_operation_type: Field,\n) -> pub Field {\n    let operation_type_int = operation_type as u32;\n    assert(operation_type_int <= 2, \"Invalid operation type\");\n\n    // Verify old wallet commitment\n    let computed_old_commitment = compute_wallet_commitment(old_wallet);\n    assert(computed_old_commitment == old_wallet_commitment, \"Old wallet commitment mismatch\");\n\n    // Verify Merkle inclusion proof\n    let old_index_int = old_index as u32;\n    assert(\n        old_merkle_root == excute_merkle_root(old_wallet_commitment, old_hash_path, old_index_int),\n        \"Invalid Merkle proof\"\n    );\n\n    // Transfer validation\n    let transfer_is_active = (operation_type_int == 0) | (operation_type_int == 2);\n    if transfer_is_active {\n        let transfer_index_int = transfer_index as u32;\n        let transfer_mint_int = transfer_mint as u32;\n        let transfer_direction_int = transfer_direction as u32;\n\n        assert(\n            (transfer_direction_int == TRANSFER_DEPOSIT) | (transfer_direction_int == TRANSFER_WITHDRAW),\n            \"Transfer direction must be DEPOSIT or WITHDRAW\"\n        );\n        assert(transfer_index_int < TOTAL_TOKEN, \"Transfer index out of bounds\");\n        assert(transfer_mint_int < TOTAL_TOKEN, \"Transfer mint token out of bounds\");\n\n        let transfer_amount_int = transfer_amount as i32;\n        assert(transfer_amount_int > 0, \"Transfer amount must be positive\");\n    }\n\n    // Order validation\n    let order_is_active = (operation_type_int == 1) | (operation_type_int == 2);\n    if order_is_active {\n        let order_index_int = order_index as u32;\n        let order_token_in_int = order_token_in as u32;\n        let order_token_out_int = order_token_out as u32;\n        let order_operation_type_int = order_operation_type as u32;\n\n        assert(order_operation_type_int < TOTAL_ORDER_OP, \"Invalid order operation type\");\n        assert(order_index_int < MAX_PENDING_ORDER, \"Order index out of bounds\");\n\n        let price_int = order_price as i32;\n        let quantity_int = order_quantity as i32;\n\n        assert(price_int > 0, \"Price must be positive\");\n        assert(quantity_int > 0, \"Quantity must be positive\");\n\n        assert(\n            (order_direction == BUY) | (order_direction == SELL),\n            \"Order direction must be BUY or SELL constant\"\n        );\n\n        assert(order_token_in_int < TOTAL_TOKEN, \"Order token_in out of bounds\");\n        assert(order_token_out_int < TOTAL_TOKEN, \"Order token_out out of bounds\");\n        assert(order_token_in != order_token_out, \"Cannot trade same token\");\n    }\n\n    // Process transfer\n    let mut intermediate_available = old_wallet.available_balances;\n    let mut intermediate_reserved = old_wallet.reserved_balances;\n\n    if transfer_is_active {\n        let transfer_index_int = transfer_index as u32;\n        let transfer_direction_int = transfer_direction as u32;\n\n        if transfer_direction_int == TRANSFER_DEPOSIT {\n            intermediate_available[transfer_index_int] = old_wallet.available_balances[transfer_index_int] + transfer_amount;\n            intermediate_reserved[transfer_index_int] = old_wallet.reserved_balances[transfer_index_int];\n\n            for i in 0..TOTAL_TOKEN {\n                if i != transfer_index_int {\n                    assert(\n                        intermediate_available[i] == old_wallet.available_balances[i],\n                        \"Available balance changed unexpectedly during deposit\"\n                    );\n                    assert(\n                        intermediate_reserved[i] == old_wallet.reserved_balances[i],\n                        \"Reserved balance changed unexpectedly during deposit\"\n                    );\n                }\n            }\n        } else {\n            let check_amount = old_wallet.available_balances[transfer_index_int].lt(transfer_amount);\n            assert(!check_amount, \"Insufficient balance for withdrawal\");\n\n            intermediate_available[transfer_index_int] = old_wallet.available_balances[transfer_index_int] - transfer_amount;\n            intermediate_reserved[transfer_index_int] = old_wallet.reserved_balances[transfer_index_int];\n\n            assert(old_wallet.fees == 0, \"Must settle fees before withdrawal\");\n\n            for i in 0..TOTAL_TOKEN {\n                if i != transfer_index_int {\n                    assert(\n                        intermediate_available[i] == old_wallet.available_balances[i],\n                        \"Available balance changed unexpectedly during withdrawal\"\n                    );\n                    assert(\n                        intermediate_reserved[i] == old_wallet.reserved_balances[i],\n                        \"Reserved balance changed unexpectedly during withdrawal\"\n                    );\n                }\n            }\n        }\n    }\n\n    // Process order\n    let mut final_available = intermediate_available;\n    let mut final_reserved = intermediate_reserved;\n    let mut final_orders = old_wallet.orders_list;\n\n    if order_is_active {\n        let order_index_int = order_index as u32;\n        let order_token_out_int = order_token_out as u32;\n        let order_operation_type_int = order_operation_type as u32;\n\n        if order_operation_type_int == OP_CREATE_ORDER {\n            assert(old_wallet.orders_list[order_index_int] == 0, \"Order slot must be empty\");\n\n            if order_direction == SELL {\n                let check_amount = intermediate_available[order_token_out_int].lt(order_quantity);\n                assert(!check_amount, \"Insufficient available balance for order\");\n\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] - order_quantity;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] + order_quantity;\n            } else {\n                // BUY order: calculate total cost (integer only, no decimals)\n                let total_cost = order_price * order_quantity;\n                assert(\n                    total_cost.lt(order_price) == false,\n                    \"Order cost overflow - price * quantity too large\"\n                );\n\n                let check_amount = intermediate_available[order_token_out_int].lt(total_cost);\n                assert(!check_amount, \"Insufficient available balance for order\");\n\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] - total_cost;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] + total_cost;\n            }\n\n            for i in 0..TOTAL_TOKEN {\n                if i != order_token_out_int {\n                    assert(\n                        final_available[i] == intermediate_available[i],\n                        \"Available balance changed unexpectedly during order creation\"\n                    );\n                    assert(\n                        final_reserved[i] == intermediate_reserved[i],\n                        \"Reserved balance changed unexpectedly during order creation\"\n                    );\n                }\n            }\n\n            let new_order = Order {\n                price: order_price,\n                quantity: order_quantity,\n                direction: order_direction,\n                token_in: order_token_in,\n                token_out: order_token_out,\n            };\n            let new_order_commitment = compute_order_commitment(new_order);\n\n            final_orders[order_index_int] = new_order_commitment;\n\n            for i in 0..MAX_PENDING_ORDER {\n                if i != order_index_int {\n                    assert(\n                        final_orders[i] == old_wallet.orders_list[i],\n                        \"Other orders changed unexpectedly during order creation\"\n                    );\n                }\n            }\n\n        } else {\n            assert(order_operation_type_int == OP_CANCEL_ORDER, \"Invalid order operation for cancellation\");\n            assert(old_wallet.orders_list[order_index_int] != 0, \"Order slot must be filled for cancellation\");\n\n            let expected_order = Order {\n                price: order_price,\n                quantity: order_quantity,\n                direction: order_direction,\n                token_in: order_token_in,\n                token_out: order_token_out,\n            };\n            let expected_order_commitment = compute_order_commitment(expected_order);\n            assert(\n                old_wallet.orders_list[order_index_int] == expected_order_commitment,\n                \"Order details mismatch - cancellation data does not match existing order\"\n            );\n\n            if order_direction == SELL {\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] + order_quantity;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] - order_quantity;\n            } else {\n                // BUY cancellation: return reserved cost to available\n                let total_cost = order_price * order_quantity;\n                assert(\n                    total_cost.lt(order_price) == false,\n                    \"Order cost overflow during cancellation\"\n                );\n\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] + total_cost;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] - total_cost;\n            }\n\n            for i in 0..TOTAL_TOKEN {\n                if i != order_token_out_int {\n                    assert(\n                        final_available[i] == intermediate_available[i],\n                        \"Available balance changed unexpectedly during order cancellation\"\n                    );\n                    assert(\n                        final_reserved[i] == intermediate_reserved[i],\n                        \"Reserved balance changed unexpectedly during order cancellation\"\n                    );\n                }\n            }\n            final_orders[order_index_int] = 0;\n            for i in 0..MAX_PENDING_ORDER {\n                if i != order_index_int {\n                    assert(\n                        final_orders[i] == old_wallet.orders_list[i],\n                        \"Other orders changed unexpectedly during order cancellation\"\n                    );\n                }\n            }\n        }\n    }\n\n    // Verify no changes if no operations\n    if !transfer_is_active & !order_is_active {\n        for i in 0..TOTAL_TOKEN {\n            assert(\n                final_available[i] == old_wallet.available_balances[i],\n                \"Available balance should not change without transfer or order\"\n            );\n            assert(\n                final_reserved[i] == old_wallet.reserved_balances[i],\n                \"Reserved balance should not change without transfer or order\"\n            );\n        }\n        for i in 0..MAX_PENDING_ORDER {\n            assert(\n                final_orders[i] == old_wallet.orders_list[i],\n                \"Orders should not change without order operation\"\n            );\n        }\n    }\n\n    // Create new wallet with incremented nonce\n    let new_nonce = old_wallet.keys.nonce + 1;\n\n    // Verify new blinder is derived correctly\n    let expected_new_blinder = Poseidon2::hash([old_wallet.blinder, new_nonce], 2);\n    assert(expected_new_blinder == new_blinder, \"New blinder derivation mismatch\");\n\n    let new_wallet = Wallet {\n        available_balances: final_available,\n        reserved_balances: final_reserved,\n        orders_list: final_orders,\n        fees: old_wallet.fees,  // Fees unchanged in update (only in match_settle)\n        keys: PublicKeyChain {\n            pk_root: old_wallet.keys.pk_root,\n            pk_match: old_wallet.keys.pk_match,\n            nonce: new_nonce,\n        },\n        blinder: new_blinder,\n    };\n\n    let computed_new_commitment = compute_wallet_commitment(new_wallet);\n    assert(computed_new_commitment == new_wallet_commitment, \"New wallet commitment mismatch\");\n\n    // Compute nullifier\n    let nullifier = Poseidon2::hash([old_wallet.blinder, old_wallet_commitment], 2);\n\n    nullifier\n}\n",
      "path": "/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/wallet_update_state/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "lt_32_hint",
    "decompose_hint",
    "lte_16_hint",
    "directive_integer_quotient",
    "directive_invert"
  ]
}