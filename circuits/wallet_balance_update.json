{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":10588572840829191659,"abi":{"parameters":[{"name":"old_wallet_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"new_wallet_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"old_merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"transfer_direction","type":{"kind":"field"},"visibility":"public"},{"name":"transfer_mint","type":{"kind":"field"},"visibility":"public"},{"name":"transfer_amount","type":{"kind":"field"},"visibility":"public"},{"name":"user_secret","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"old_available_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_reserved_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_orders_list","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"old_fees","type":{"kind":"field"},"visibility":"private"},{"name":"old_index","type":{"kind":"field"},"visibility":"private"},{"name":"old_hash_path","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_available_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_reserved_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"transfer_index","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"72":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse crate::constants::GLOBAL_DEPTH;\n\npub fn excute_merkle_root(\n    commitment: Field,\n    hash_path: [Field; GLOBAL_DEPTH],\n    index: u32,\n) -> Field {\n    let mut hash = commitment;\n\n    for i in 0..GLOBAL_DEPTH {\n        let is_right = ((index >> (i as u8)) & 1) == 1;\n        hash = if is_right {\n            Poseidon2::hash([hash, hash_path[i]], 2)\n        } else {\n            Poseidon2::hash([hash_path[i], hash], 2)\n        };\n    }\n    hash\n}","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/common/src/merkle.nr"},"74":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/gary/nargo/github.com/noir-lang/poseidonv0.1.1/src/poseidon2.nr"},"82":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse dep::common::merkle::excute_merkle_root;\nuse dep::common::constants::{\n    GLOBAL_DEPTH,\n    MAX_PENDING_ORDER,\n    TOTAL_TOKEN,\n    TRANSFER_DEPOSIT,\n    TRANSFER_WITHDRAW,\n    TOTAL_OP_TRANSFER,\n};\n\nfn main(\n    // PUBLIC\n    old_wallet_commitment: pub Field,\n    new_wallet_commitment: pub Field,     \n    old_merkle_root: pub Field,\n\n    // External transfer\n    transfer_direction: pub Field,         \n    transfer_mint: pub Field,             \n    transfer_amount: pub Field,            \n\n    // PRIVATE\n    user_secret: Field,\n    nonce: Field,\n    old_available_balances: [Field; TOTAL_TOKEN],\n    old_reserved_balances: [Field; TOTAL_TOKEN],\n    old_orders_list: [Field; MAX_PENDING_ORDER],\n    old_fees: Field,\n    old_index: Field,\n    old_hash_path: [Field; GLOBAL_DEPTH],\n\n    // PRIVATE\n    new_available_balances: [Field; TOTAL_TOKEN],\n    new_reserved_balances: [Field; TOTAL_TOKEN],\n    // PRIVATE \n    transfer_index: Field\n) -> pub (Field, Field, Field) {\n    let nonce_int = nonce as u32;\n    let transfer_index_int = transfer_index as u32;\n    let transfer_mint_int = transfer_mint as u32;\n    let transfer_direction_int = transfer_direction as u32;\n\n    assert((transfer_direction_int == TRANSFER_DEPOSIT) | (transfer_direction_int == TRANSFER_WITHDRAW));\n    assert(transfer_index_int < TOTAL_TOKEN);\n    assert(transfer_mint_int < TOTAL_TOKEN);\n    assert(transfer_direction_int < TOTAL_OP_TRANSFER);\n\n    let transfer_amount_int = transfer_amount as i32;\n    assert(transfer_amount_int > 0); // Amount must be positive\n\n    let old_randomness = Poseidon2::hash([user_secret, nonce], 2);\n    let new_randomness = Poseidon2::hash([user_secret, (nonce_int + 1) as Field], 2);\n\n    let old_available_hash = Poseidon2::hash(old_available_balances, TOTAL_TOKEN);\n    let old_reserved_hash = Poseidon2::hash(old_reserved_balances, TOTAL_TOKEN);\n    let old_orders_hash = Poseidon2::hash(old_orders_list, MAX_PENDING_ORDER);\n\n    let computed_old_commitment = Poseidon2::hash(\n        [old_available_hash, old_reserved_hash, old_orders_hash, old_fees, old_randomness],\n        5\n    );\n    assert(computed_old_commitment == old_wallet_commitment);\n\n    let old_index_int = old_index as u32;\n    assert(old_merkle_root == excute_merkle_root(old_wallet_commitment, old_hash_path, old_index_int));\n\n    if transfer_direction_int == TRANSFER_DEPOSIT {\n        assert(new_available_balances[transfer_index_int] == old_available_balances[transfer_index_int] + transfer_amount);\n        assert(new_reserved_balances[transfer_index_int] == old_reserved_balances[transfer_index_int]);\n\n        for i in 0..TOTAL_TOKEN {\n            if i != transfer_index_int {\n                assert(new_available_balances[i] == old_available_balances[i]);\n                assert(new_reserved_balances[i] == old_reserved_balances[i]);\n            }\n        }\n\n    } else {\n        let check_amount = old_available_balances[transfer_index_int].lt(transfer_amount);\n        assert(!check_amount, \"Not enough amount\");\n        assert(new_available_balances[transfer_index_int] == old_available_balances[transfer_index_int] - transfer_amount);\n        assert(new_reserved_balances[transfer_index_int] == old_reserved_balances[transfer_index_int]);\n        assert(old_fees == 0);\n\n        for i in 0..TOTAL_TOKEN {\n            if i != transfer_index_int {\n                assert(new_available_balances[i] == old_available_balances[i]);\n                assert(new_reserved_balances[i] == old_reserved_balances[i]);\n            }\n        }\n    }\n\n    let new_available_hash = Poseidon2::hash(new_available_balances, TOTAL_TOKEN);\n    let new_reserved_hash = Poseidon2::hash(new_reserved_balances, TOTAL_TOKEN);\n    let new_orders_hash = old_orders_hash;\n\n    let computed_new_commitment = Poseidon2::hash(\n        [new_available_hash, new_reserved_hash, new_orders_hash, old_fees, new_randomness],\n        5\n    );\n\n    assert(computed_new_commitment == new_wallet_commitment);\n\n    let nullifier = Poseidon2::hash([user_secret, old_wallet_commitment], 2);\n    (nullifier, new_wallet_commitment, nonce + 1)\n}\n","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/wallet_balance_update/src/main.nr"}},"names":["main"],"brillig_names":["lt_32_hint","decompose_hint","lte_16_hint","directive_integer_quotient","directive_invert"]}