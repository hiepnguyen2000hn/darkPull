{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":479016879354866520,"abi":{"parameters":[{"name":"witness","type":{"kind":"struct","path":"MatchWitness","fields":[{"name":"order0","type":{"kind":"struct","path":"common::data::Order","fields":[{"name":"price","type":{"kind":"field"}},{"name":"quantity","type":{"kind":"field"}},{"name":"direction","type":{"kind":"field"}},{"name":"token_in","type":{"kind":"field"}},{"name":"token_out","type":{"kind":"field"}}]}},{"name":"order0_index","type":{"kind":"field"}},{"name":"party0_old_wallet","type":{"kind":"struct","path":"common::data::Wallet","fields":[{"name":"available_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}}},{"name":"reserved_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}}},{"name":"orders_list","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"fees","type":{"kind":"field"}},{"name":"keys","type":{"kind":"struct","path":"common::data::PublicKeyChain","fields":[{"name":"pk_root","type":{"kind":"field"}},{"name":"pk_match","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}},{"name":"blinder","type":{"kind":"field"}}]}},{"name":"sk_match_0","type":{"kind":"field"}},{"name":"party0_new_blinder","type":{"kind":"field"}},{"name":"order1","type":{"kind":"struct","path":"common::data::Order","fields":[{"name":"price","type":{"kind":"field"}},{"name":"quantity","type":{"kind":"field"}},{"name":"direction","type":{"kind":"field"}},{"name":"token_in","type":{"kind":"field"}},{"name":"token_out","type":{"kind":"field"}}]}},{"name":"order1_index","type":{"kind":"field"}},{"name":"party1_old_wallet","type":{"kind":"struct","path":"common::data::Wallet","fields":[{"name":"available_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}}},{"name":"reserved_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}}},{"name":"orders_list","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"fees","type":{"kind":"field"}},{"name":"keys","type":{"kind":"struct","path":"common::data::PublicKeyChain","fields":[{"name":"pk_root","type":{"kind":"field"}},{"name":"pk_match","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}},{"name":"blinder","type":{"kind":"field"}}]}},{"name":"sk_match_1","type":{"kind":"field"}},{"name":"party1_new_blinder","type":{"kind":"field"}},{"name":"match_result","type":{"kind":"struct","path":"MatchResult","fields":[{"name":"matched_quantity","type":{"kind":"field"}},{"name":"execution_price","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"statement","type":{"kind":"struct","path":"MatchStatement","fields":[{"name":"party0_old_commitment","type":{"kind":"field"}},{"name":"party1_old_commitment","type":{"kind":"field"}},{"name":"party0_nullifier","type":{"kind":"field"}},{"name":"party1_nullifier","type":{"kind":"field"}},{"name":"party0_new_commitment","type":{"kind":"field"}},{"name":"party1_new_commitment","type":{"kind":"field"}}]},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"73":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse crate::constants::{\n    MAX_PENDING_ORDER,\n    TOTAL_TOKEN,\n};\n\npub struct Order {\n    pub price: Field,\n    pub quantity: Field,\n    pub direction: Field,\n    pub token_in: Field,\n    pub token_out: Field,\n}\n\npub struct PublicKeyChain {\n    pub pk_root: Field,\n    pub pk_match: Field,  // Public matching key = Poseidon(sk_match)\n    pub nonce: Field,     // Nonce for key rotation (0 for no rotation)\n}\n\npub struct Wallet {\n    pub available_balances: [Field; TOTAL_TOKEN],\n    pub reserved_balances: [Field; TOTAL_TOKEN],\n    pub orders_list: [Field; MAX_PENDING_ORDER],\n    pub fees: Field,\n    pub keys: PublicKeyChain,  // Public key chain\n    pub blinder: Field,        // Randomness for commitment\n}\n\n// Shared helper functions\npub fn compute_wallet_commitment(wallet: Wallet) -> Field {\n    let available_hash = Poseidon2::hash(wallet.available_balances, TOTAL_TOKEN);\n    let reserved_hash = Poseidon2::hash(wallet.reserved_balances, TOTAL_TOKEN);\n    let orders_hash = Poseidon2::hash(wallet.orders_list, MAX_PENDING_ORDER);\n\n    // Hash the public key chain (pk_root, pk_match, nonce)\n    let keys_hash = Poseidon2::hash(\n        [wallet.keys.pk_root, wallet.keys.pk_match, wallet.keys.nonce],\n        3\n    );\n\n    // Commitment = Hash(balances, orders, keys, fees, blinder)\n    Poseidon2::hash(\n        [available_hash, reserved_hash, orders_hash, keys_hash, wallet.fees, wallet.blinder],\n        6\n    )\n}\n\npub fn compute_order_commitment(order: Order) -> Field {\n    let order_array = [order.price, order.quantity, order.direction, order.token_in, order.token_out];\n    Poseidon2::hash(order_array, 5)\n}\n","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/common/src/data.nr"},"75":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/gary/nargo/github.com/noir-lang/poseidonv0.1.1/src/poseidon2.nr"},"84":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse dep::common::constants::{\n    BUY,\n    SELL\n};\nuse dep::common::data::{\n    Order,\n    Wallet,\n    compute_wallet_commitment,\n    compute_order_commitment,\n};\n\nstruct MatchResult {\n    matched_quantity: Field,\n    execution_price: Field,\n}\n\nstruct MatchWitness {\n    order0: Order,\n    order0_index: Field,\n    party0_old_wallet: Wallet,\n    sk_match_0: Field,         // Secret matching key for party 0 (private witness)\n    party0_new_blinder: Field, \n\n    order1: Order,\n    order1_index: Field,\n    party1_old_wallet: Wallet,\n    sk_match_1: Field,         // Secret matching key for party 1 (private witness)\n    party1_new_blinder: Field, \n\n    match_result: MatchResult,\n}\n\nstruct MatchStatement {\n    party0_old_commitment: Field,\n    party1_old_commitment: Field,\n    party0_nullifier: Field,\n    party1_nullifier: Field,\n    party0_new_commitment: Field,\n    party1_new_commitment: Field,\n}\n\nfn main(witness: MatchWitness, statement: pub MatchStatement) {\n    verify_old_commitments(witness, statement);\n    validate_matching_engine(witness);\n\n    let party0_new_wallet = apply_match_to_wallet(\n        witness.party0_old_wallet,\n        witness.order0,\n        witness.order0_index,\n        witness.match_result\n    );\n\n    let party1_new_wallet = apply_match_to_wallet(\n        witness.party1_old_wallet,\n        witness.order1,\n        witness.order1_index,\n        witness.match_result\n    );\n\n    verify_new_commitments(\n        witness,\n        statement,\n        party0_new_wallet,\n        party1_new_wallet\n    );\n}\n\nfn verify_old_commitments(witness: MatchWitness, statement: MatchStatement) {\n    // Verify sk_match\n    let computed_pk_match_0 = Poseidon2::hash([witness.sk_match_0], 1);\n    assert(computed_pk_match_0 == witness.party0_old_wallet.keys.pk_match, \"Party 0 sk_match verification failed\");\n\n    let computed_pk_match_1 = Poseidon2::hash([witness.sk_match_1], 1);\n    assert(computed_pk_match_1 == witness.party1_old_wallet.keys.pk_match, \"Party 1 sk_match verification failed\");\n\n    // Verify old wallet commitment\n    let computed_party0_old = compute_wallet_commitment(witness.party0_old_wallet);\n    assert(computed_party0_old == statement.party0_old_commitment, \"Party 0 old commitment mismatch\");\n\n    let computed_party1_old = compute_wallet_commitment(witness.party1_old_wallet);\n    assert(computed_party1_old == statement.party1_old_commitment, \"Party 1 old commitment mismatch\");\n\n    // Verify nullifiers\n    let computed_party0_nullifier = Poseidon2::hash([witness.sk_match_0, statement.party0_old_commitment], 2);\n    assert(computed_party0_nullifier == statement.party0_nullifier, \"Party 0 nullifier mismatch\");\n\n    let computed_party1_nullifier = Poseidon2::hash([witness.sk_match_1, statement.party1_old_commitment], 2);\n    assert(computed_party1_nullifier == statement.party1_nullifier, \"Party 1 nullifier mismatch\");\n\n    // Verify orders exist at claimed indices\n    let order0_commitment = compute_order_commitment(witness.order0);\n    assert(witness.party0_old_wallet.orders_list[witness.order0_index as u32] == order0_commitment, \"Party 0 order not found at index\");\n\n    let order1_commitment = compute_order_commitment(witness.order1);\n    assert(witness.party1_old_wallet.orders_list[witness.order1_index as u32] == order1_commitment, \"Party 1 order not found at index\");\n}\n\nfn verify_new_commitments(\n    witness: MatchWitness,\n    statement: MatchStatement,\n    mut party0_new_wallet: Wallet,\n    mut party1_new_wallet: Wallet\n) {\n    // Verify blinder\n    \n    // Verify nonce increment for party 0\n    let expected_nonce_0 = witness.party0_old_wallet.keys.nonce + 1;\n    assert(party0_new_wallet.keys.nonce == expected_nonce_0, \"Party 0 nonce must increment by 1\");\n\n    // Set new blinder for party 0\n    let expected_new_blinder_0 = Poseidon2::hash([witness.party0_old_wallet.blinder, expected_nonce_0], 2);\n    assert(expected_new_blinder_0 == witness.party0_new_blinder, \"New blinder 0 is not valid\");\n    party0_new_wallet.blinder = witness.party0_new_blinder;\n    let computed_party0_new = compute_wallet_commitment(party0_new_wallet);\n    assert(computed_party0_new == statement.party0_new_commitment, \"Party 0 new commitment mismatch\");\n\n    // Verify nonce increment for party 1\n    let expected_nonce_1 = witness.party1_old_wallet.keys.nonce + 1;\n    assert(party1_new_wallet.keys.nonce == expected_nonce_1, \"Party 1 nonce must increment by 1\");\n    let expected_new_blinder_1 = Poseidon2::hash([witness.party1_old_wallet.blinder, expected_nonce_1], 2);\n    assert(expected_new_blinder_1 == witness.party1_new_blinder, \"New blinder 1 is not valid\");\n\n    // Set new blinder for party 1\n    party1_new_wallet.blinder = witness.party1_new_blinder;\n    let computed_party1_new = compute_wallet_commitment(party1_new_wallet);\n    assert(computed_party1_new == statement.party1_new_commitment, \"Party 1 new commitment mismatch\");\n}\n\n\nfn validate_matching_engine(witness: MatchWitness) {\n    // VALID MATCH SETTLE: Core matching logic\n    let order0 = witness.order0;\n    let order1 = witness.order1;\n    let match_result = witness.match_result;\n\n    let orders_opposite = ((order0.direction == BUY) & (order1.direction == SELL)) |\n                          ((order0.direction == SELL) & (order1.direction == BUY));\n    assert(orders_opposite, \"Orders must be on opposite sides\");\n\n    assert(order0.token_in == order1.token_out, \"Token pair mismatch: order0.token_in != order1.token_out\");\n    assert(order0.token_out == order1.token_in, \"Token pair mismatch: order0.token_out != order1.token_in\");\n\n    // If order0 is BUY: order0.price >= execution_price >= order1.price\n    // If order0 is SELL: order1.price >= execution_price >= order0.price\n    if order0.direction == BUY {\n        // Order0 is buyer, must accept execution price\n        let buyer_price_ok = order0.price.lt(match_result.execution_price) == false;\n        assert(buyer_price_ok, \"Buyer price too low: order0.price < execution_price\");\n\n        // Order1 is seller, must accept execution price\n        let seller_price_ok = match_result.execution_price.lt(order1.price) == false;\n        assert(seller_price_ok, \"Seller price too high: execution_price < order1.price\");\n    } else {\n        // Order0 is seller\n        let seller_price_ok = match_result.execution_price.lt(order0.price) == false;\n        assert(seller_price_ok, \"Seller price too high: execution_price < order0.price\");\n\n        // Order1 is buyer\n        let buyer_price_ok = order1.price.lt(match_result.execution_price) == false;\n        assert(buyer_price_ok, \"Buyer price too low: order1.price < execution_price\");\n    }\n\n    // 4. Verify matched quantity doesn't exceed order amounts\n    let quantity_valid0 = order0.quantity.lt(match_result.matched_quantity) == false;\n    assert(quantity_valid0, \"Matched quantity exceeds order0 quantity\");\n\n    let quantity_valid1 = order1.quantity.lt(match_result.matched_quantity) == false;\n    assert(quantity_valid1, \"Matched quantity exceeds order1 quantity\");\n\n    // 5. Verify matched quantity and price are positive\n    let quantity_positive = match_result.matched_quantity.lt(1) == false;\n    assert(quantity_positive, \"Matched quantity must be positive\");\n\n    let price_positive = match_result.execution_price.lt(1) == false;\n    assert(price_positive, \"Execution price must be positive\");\n}\n\nfn apply_match_to_wallet(\n    mut wallet: Wallet,\n    order: Order,\n    order_index: Field,\n    match_result: MatchResult\n) -> Wallet {\n    let order_index_int = order_index as u32;\n    let quantity_matched = match_result.matched_quantity;\n\n    // Calculate total cost (integer only, no decimals)\n    let total_cost = match_result.execution_price * quantity_matched;\n    assert(\n        total_cost.lt(match_result.execution_price) == false,\n        \"Order cost overflow - price * quantity too large\"\n    );\n\n    let token_in_idx = order.token_in as u32;\n    let token_out_idx = order.token_out as u32;\n\n    // Update balances based on order direction\n    if order.direction == SELL {\n        let sufficient_balance_sell = wallet.reserved_balances[token_out_idx].lt(quantity_matched) == false;\n        assert(sufficient_balance_sell, \"Insufficient reserved balance for SELL\");\n        wallet.reserved_balances[token_out_idx] = wallet.reserved_balances[token_out_idx] - quantity_matched;\n        wallet.available_balances[token_in_idx] = wallet.available_balances[token_in_idx] + total_cost;\n    } else {\n        let sufficient_balance_buy = wallet.reserved_balances[token_out_idx].lt(total_cost) == false;\n        assert(sufficient_balance_buy, \"Insufficient reserved balance for BUY\");\n        wallet.reserved_balances[token_out_idx] = wallet.reserved_balances[token_out_idx] - total_cost;\n        wallet.available_balances[token_in_idx] = wallet.available_balances[token_in_idx] + quantity_matched;\n    }\n\n    // Update order in orders list\n    let remaining_quantity = order.quantity - quantity_matched;\n    if remaining_quantity == 0 {\n        wallet.orders_list[order_index_int] = 0;\n    } else {\n        let updated_order = Order {\n            price: order.price,\n            quantity: remaining_quantity,\n            direction: order.direction,\n            token_in: order.token_in,\n            token_out: order.token_out,\n        };\n        wallet.orders_list[order_index_int] = compute_order_commitment(updated_order);\n    }\n\n    // Increment nonce (each match creates new wallet state)\n    wallet.keys.nonce = wallet.keys.nonce + 1;\n\n    wallet\n}\n","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/noir_match_settle/src/main.nr"}},"names":["main"],"brillig_names":["lt_32_hint","decompose_hint","lte_16_hint","directive_integer_quotient","directive_invert"]}